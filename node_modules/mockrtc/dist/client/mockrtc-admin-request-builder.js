"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCAdminRequestBuilder = void 0;
const graphql_tag_1 = require("graphql-tag");
// Long-term, it'd be great to use the 'official' export path of mockttp/pluggable-admin, but
// if we do so, then TypeScript <4.7 doesn't understand it here or downstream, so we get errors.
// We don't want to use the main-exported version to avoid bundling all of Mockttp in browsers.
// For now we have to use the direct import. We can update once TS 4.7 is widely used.
const BrowserPluggableAdmin = require("mockttp/dist/pluggable-admin-api/pluggable-admin.browser");
/**
 * This is part of Mockttp's experimental 'pluggable admin' API. This may change
 * unpredictably, even in minor releases.
 *
 * @internal
 */
class MockRTCAdminRequestBuilder {
    buildCreatePeerQuery(handlerSteps, adminStream) {
        return {
            query: (0, graphql_tag_1.default) `
                mutation CreatePeer($peerData: RTCHandlerData!) {
                    createPeer(data: $peerData) {
                        peerId
                    }
                }
            `,
            variables: {
                peerData: {
                    steps: handlerSteps.map(step => BrowserPluggableAdmin.Serialization.serialize(step, adminStream))
                }
            },
            transformResponse: ({ createPeer }) => createPeer
        };
    }
    buildAddRuleQuery(matchers, handlerSteps, adminStream) {
        return {
            query: (0, graphql_tag_1.default) `
                mutation AddRTCRule($ruleData: RTCRuleData!) {
                    addRTCRule(data: $ruleData)
                }
            `,
            variables: {
                ruleData: {
                    matchers: matchers.map(matcher => BrowserPluggableAdmin.Serialization.serialize(matcher, adminStream)),
                    steps: handlerSteps.map(step => BrowserPluggableAdmin.Serialization.serialize(step, adminStream))
                }
            }
        };
    }
    buildSetRulesQuery(rules, adminStream) {
        return {
            query: (0, graphql_tag_1.default) `
                mutation SetRTCRules($ruleData: [RTCRuleData!]!) {
                    setRTCRules(data: $ruleData)
                }
            `,
            variables: {
                ruleData: rules.map(({ matchers, steps }) => ({
                    matchers: matchers.map(matcher => BrowserPluggableAdmin.Serialization.serialize(matcher, adminStream)),
                    steps: steps.map(step => BrowserPluggableAdmin.Serialization.serialize(step, adminStream))
                }))
            }
        };
    }
    buildSubscriptionRequest(event) {
        const query = {
            'peer-connected': (0, graphql_tag_1.default) `subscription OnPeerConnected {
                peerConnected {
                    peerId
                    sessionId

                    metadata
                    timingEvents

                    localSessionDescription { type, sdp }
                    remoteSessionDescription { type, sdp }
                    selectedLocalCandidate { address, port, protocol, type }
                    selectedRemoteCandidate { address, port, protocol, type }
                }
            }`,
            'peer-disconnected': (0, graphql_tag_1.default) `subscription OnPeerDisconnected {
                peerDisconnected {
                    peerId
                    sessionId
                    timingEvents
                }
            }`,
            'external-peer-attached': (0, graphql_tag_1.default) `subscription OnExternalPeerAttached {
                externalPeerAttached {
                    peerId
                    sessionId
                    timingEvents
                    externalConnection {
                        sessionId
                        localSessionDescription { type, sdp }
                        remoteSessionDescription { type, sdp }
                        selectedLocalCandidate { address, port, protocol, type }
                        selectedRemoteCandidate { address, port, protocol, type }
                    }
                }
            }`,
            'data-channel-opened': (0, graphql_tag_1.default) `subscription OnDataChannelOpen {
                dataChannelOpened {
                    peerId
                    sessionId
                    channelId
                    channelLabel
                    channelProtocol

                    eventTimestamp
                    timingEvents
                }
            }`,
            'data-channel-message-sent': (0, graphql_tag_1.default) `subscription OnDataChannelMessageSent {
                dataChannelMessageSent {
                    peerId
                    sessionId
                    channelId
                    direction
                    content
                    isBinary

                    eventTimestamp
                    timingEvents
                }
            }`,
            'data-channel-message-received': (0, graphql_tag_1.default) `subscription OnDataChannelMessageReceived {
                dataChannelMessageReceived {
                    peerId
                    sessionId
                    channelId
                    direction
                    content
                    isBinary

                    eventTimestamp
                    timingEvents
                }
            }`,
            'data-channel-closed': (0, graphql_tag_1.default) `subscription OnDataChannelClose {
                dataChannelClosed {
                    peerId
                    sessionId
                    channelId

                    eventTimestamp
                    timingEvents
                }
            }`,
            'media-track-opened': (0, graphql_tag_1.default) `subscription OnDataChannelClose {
                mediaTrackOpened {
                    peerId
                    sessionId
                    trackMid
                    trackType
                    trackDirection

                    eventTimestamp
                    timingEvents
                }
            }`,
            'media-track-stats': (0, graphql_tag_1.default) `subscription OnDataChannelClose {
                mediaTrackStats {
                    peerId
                    sessionId
                    trackMid
                    totalBytesSent
                    totalBytesReceived

                    eventTimestamp
                    timingEvents
                }
            }`,
            'media-track-closed': (0, graphql_tag_1.default) `subscription OnDataChannelClose {
                mediaTrackClosed {
                    peerId
                    sessionId
                    trackMid

                    eventTimestamp
                    timingEvents
                }
            }`
        }[event];
        if (!query)
            return; // Unrecognized event, we can't subscribe to this.
        return {
            query,
            transformResponse: (result) => {
                if (result.content)
                    result.content = Buffer.from(result.content, 'base64');
                return result;
            }
        };
    }
}
exports.MockRTCAdminRequestBuilder = MockRTCAdminRequestBuilder;
//# sourceMappingURL=mockrtc-admin-request-builder.js.map