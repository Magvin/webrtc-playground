"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCClient = void 0;
// Long-term, it'd be great to use the 'official' export path of mockttp/pluggable-admin, but
// if we do so, then TypeScript <4.7 doesn't understand it here or downstream, so we get errors.
// We don't want to use the main-exported version to avoid bundling all of Mockttp in browsers.
// For now we have to use the direct import. We can update once TS 4.7 is widely used.
const BrowserPluggableAdmin = require("mockttp/dist/pluggable-admin-api/pluggable-admin.browser");
const mockrtc_base_1 = require("../mockrtc-base");
const mockrtc_remote_peer_1 = require("./mockrtc-remote-peer");
const mockrtc_admin_request_builder_1 = require("./mockrtc-admin-request-builder");
class MockRTCClient extends mockrtc_base_1.MockRTCBase {
    constructor(options = {}) {
        super();
        this.options = options;
        this.adminClient = new BrowserPluggableAdmin.AdminClient(options);
        this.requestBuilder = new mockrtc_admin_request_builder_1.MockRTCAdminRequestBuilder();
    }
    getMatchingPeer() {
        return new mockrtc_remote_peer_1.MockRTCRemotePeer('matching-peer', this.adminClient);
    }
    buildPeerFromDefinition(handlerSteps) {
        return __awaiter(this, void 0, void 0, function* () {
            const { adminStream } = this.adminClient;
            const peerData = yield this.adminClient.sendQuery(this.requestBuilder.buildCreatePeerQuery(handlerSteps, adminStream));
            const { peerId } = peerData;
            return new mockrtc_remote_peer_1.MockRTCRemotePeer(peerId, this.adminClient);
        });
    }
    addRuleFromDefinition(matchers, handlerSteps) {
        return __awaiter(this, void 0, void 0, function* () {
            const { adminStream } = this.adminClient;
            yield this.adminClient.sendQuery(this.requestBuilder.buildAddRuleQuery(matchers, handlerSteps, adminStream));
        });
    }
    setRulesFromDefinitions(rules) {
        return __awaiter(this, void 0, void 0, function* () {
            const { adminStream } = this.adminClient;
            yield this.adminClient.sendQuery(this.requestBuilder.buildSetRulesQuery(rules, adminStream));
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.adminClient.start({
                webrtc: this.options
            });
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.adminClient.stop();
        });
    }
    on(event, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const subscriptionRequest = this.requestBuilder.buildSubscriptionRequest(event);
            if (!subscriptionRequest) {
                // We just return an immediately promise if we don't recognize the event, which will quietly
                // succeed but never call the corresponding callback (the same as the server and most event
                // sources in the same kind of situation). This is what happens when the *client* doesn't
                // recognize the event. Subscribe() below handles the unknown-to-server case.
                console.warn(`Ignoring subscription for event unrecognized by MockRTC client: ${event}`);
                return;
            }
            return this.adminClient.subscribe(subscriptionRequest, callback);
        });
    }
}
exports.MockRTCClient = MockRTCClient;
//# sourceMappingURL=mockrtc-client.js.map