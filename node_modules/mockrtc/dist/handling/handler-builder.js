"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCHandlerBuilder = void 0;
const handler_step_definitions_1 = require("./handler-step-definitions");
/**
 * The builder logic for composing RTC handling behaviour for both mock peers and rules,
 * by internally queuing defined actions until a `.thenX()` method is called to compile
 * the actions into either a peer or a rule (handled by an constructor callback param).
 */
class MockRTCHandlerBuilder {
    constructor(buildCallback) {
        this.buildCallback = buildCallback;
        this.handlerSteps = [];
    }
    /**
     * Wait for a given duration, in milliseconds
     *
     * @category Steps
     */
    sleep(duration) {
        this.handlerSteps.push(new handler_step_definitions_1.WaitForDurationStepDefinition(duration));
        return this;
    }
    /**
     * Wait until the remote client has created at least one DataChannel.
     *
     * @category Steps
     */
    waitForChannel(channelLabel) {
        this.handlerSteps.push(new handler_step_definitions_1.WaitForChannelStepDefinition(channelLabel));
        return this;
    }
    /**
     * Wait until the remote client has created at least one media track
     *
     * @category Steps
     */
    waitForTrack() {
        this.handlerSteps.push(new handler_step_definitions_1.WaitForTrackStepDefinition());
        return this;
    }
    /**
     * Wait until the remote client next sends a message to us on any DataChannel.
     *
     * This looks for new messages, ignoring any messages already consumed by
     * previous steps.
     *
     * @category Steps
     */
    waitForNextMessage() {
        this.handlerSteps.push(new handler_step_definitions_1.WaitForMessageStepDefinition());
        return this;
    }
    /**
     * Wait until the remote client next sends media data on a media track.
     *
     * This waits for new media, ignoring any media already consumed by previous steps.
     *
     * @category Steps
     */
    waitForNextMedia() {
        this.handlerSteps.push(new handler_step_definitions_1.WaitForMediaStepDefinition());
        return this;
    }
    /**
     * Wait until the remote client sends a message to us on a specific DataChannel.
     *
     * This looks for new messages, ignoring any messages already consumed by
     * previous steps.
     *
     * @category Steps
     */
    waitForNextMessageOnChannel(channelLabel) {
        this.handlerSteps.push(new handler_step_definitions_1.WaitForMessageStepDefinition(channelLabel));
        return this;
    }
    /**
     * Creates a new data channel with the given name, waiting until it opens
     * before continuing.
     *
     * @category Steps
     */
    createDataChannel(channelLabel) {
        this.handlerSteps.push(new handler_step_definitions_1.CreateChannelStepDefinition(channelLabel));
        return this;
    }
    send(...args) {
        if (args[1] !== undefined) {
            const [channel, message] = args;
            this.handlerSteps.push(new handler_step_definitions_1.SendStepDefinition(channel, message));
        }
        else {
            const [message] = args;
            this.handlerSteps.push(new handler_step_definitions_1.SendStepDefinition(undefined, message));
        }
        return this;
    }
    /**
     * Immediately close the connection.
     *
     * This defines a final step, and will then create a mock peer from the full
     * set of steps you've defined, and return it wrapped in a promise. As soon
     * as the promise resolves the peer is ready to use.
     *
     * @category Final Steps
     */
    thenClose() {
        this.handlerSteps.push(new handler_step_definitions_1.CloseStepDefinition());
        return this.buildCallback(this.handlerSteps);
    }
    thenSend(...args) {
        return this.send(...args)
            .buildCallback(this.handlerSteps);
    }
    /**
     * Echo all incoming data channel messages until the other peer closes the
     * connection.
     *
     * This defines a final step, and will then create a mock peer from the full
     * set of steps you've defined, and return it wrapped in a promise. As soon
     * as the promise resolves the peer is ready to use.
     *
     * @category Final Steps
     */
    thenEcho() {
        this.handlerSteps.push(new handler_step_definitions_1.EchoStepDefinition());
        return this.buildCallback(this.handlerSteps);
    }
    /**
     * Creates a new external connection to the given remote peer connection,
     * matching the existing mocked connection, and then proxies all traffic
     * through to that peer.
     *
     * This defines a final step, and will then create a mock peer from the full
     * set of steps you've defined, and return it wrapped in a promise. As soon
     * as the promise resolves the peer is ready to use.
     *
     * @category Final Steps
     */
    thenForwardTo(peer) {
        this.handlerSteps.push(new handler_step_definitions_1.PeerProxyStepDefinition(peer));
        return this.buildCallback(this.handlerSteps);
    }
    /**
     * Proxy this connection dynamically to the 'real' target peer, whoever
     * that may be.
     *
     * This assumes that you have an existing external connection already
     * set up and attached to this mock connection.
     *
     * You can do that either by using {@link hookWebRTCConnection} or
     * {@link hookAllWebRTC} to hook your connection during normal setup to
     * automatically create an external offer to the real remote peer, or you can
     * do so manually using {@link MockRTCPeer.createExternalOffer} or
     * {@link MockRTCPeer.answerExternalOffer} and then passing the connection
     * id as {@link https://github.com/httptoolkit/mockrtc/blob/d0604f3111e0438c52aa514d00cf04ac0718dfeb/src/webrtc-hooks.ts#L83-L93 here}.
     *
     * This defines a final step, and will then create a mock peer from the full
     * set of steps you've defined, and return it wrapped in a promise. As soon
     * as the promise resolves the peer is ready to use.
     *
     * @category Final Steps
     */
    thenPassThrough() {
        this.handlerSteps.push(new handler_step_definitions_1.DynamicProxyStepDefinition());
        return this.buildCallback(this.handlerSteps);
    }
}
exports.MockRTCHandlerBuilder = MockRTCHandlerBuilder;
//# sourceMappingURL=handler-builder.js.map