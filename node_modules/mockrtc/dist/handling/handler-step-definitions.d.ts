/// <reference types="node" />
import * as PluggableAdmin from 'mockttp/dist/pluggable-admin-api/pluggable-admin.browser';
import { MockRTCSessionDescription } from '../mockrtc';
export declare type Serializable = PluggableAdmin.Serialization.Serializable;
export declare const Serializable: typeof PluggableAdmin.Serialization.Serializable;
declare type ClientServerChannel = PluggableAdmin.Serialization.ClientServerChannel;
export interface HandlerStepDefinition extends Serializable {
    readonly type: keyof typeof StepDefinitionLookup;
}
export declare class WaitForDurationStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly durationMs: number;
    readonly type = "wait-for-duration";
    constructor(durationMs: number);
    explain(): string;
}
export declare class WaitForChannelStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly channelLabel?: string | undefined;
    readonly type = "wait-for-rtc-data-channel";
    constructor(channelLabel?: string | undefined);
    explain(): string;
}
export declare class WaitForMessageStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly channelLabel?: string | undefined;
    readonly type = "wait-for-rtc-message";
    constructor(channelLabel?: string | undefined);
    explain(): string;
}
export declare class WaitForTrackStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly type = "wait-for-rtc-track";
    explain(): string;
}
export declare class WaitForMediaStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly type = "wait-for-rtc-media";
    explain(): string;
}
export declare class CreateChannelStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly channelLabel: string;
    readonly type = "create-rtc-data-channel";
    constructor(channelLabel: string);
    explain(): string;
}
export declare class SendStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly channelLabel: string | undefined;
    readonly message: string | Buffer;
    readonly type = "send-rtc-data-message";
    constructor(channelLabel: string | undefined, message: string | Buffer);
    explain(): string;
}
export declare class CloseStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly type = "close-rtc-connection";
    explain(): string;
}
export declare class EchoStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly type = "echo-rtc";
    explain(): string;
}
export declare class PeerProxyStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly type = "rtc-peer-proxy";
    protected getAnswer: (offer: MockRTCSessionDescription) => Promise<RTCSessionDescriptionInit>;
    constructor(connectionTarget: RTCPeerConnection | ((offer: MockRTCSessionDescription) => Promise<RTCSessionDescriptionInit>));
    explain(): string;
    serialize(channel: ClientServerChannel): {};
}
export declare class DynamicProxyStepDefinition extends Serializable implements HandlerStepDefinition {
    readonly type = "rtc-dynamic-proxy";
    explain(): string;
}
export declare const StepDefinitionLookup: {
    'wait-for-duration': typeof WaitForDurationStepDefinition;
    'wait-for-rtc-data-channel': typeof WaitForChannelStepDefinition;
    'wait-for-rtc-track': typeof WaitForTrackStepDefinition;
    'wait-for-rtc-media': typeof WaitForMediaStepDefinition;
    'wait-for-rtc-message': typeof WaitForMessageStepDefinition;
    'create-rtc-data-channel': typeof CreateChannelStepDefinition;
    'send-rtc-data-message': typeof SendStepDefinition;
    'close-rtc-connection': typeof CloseStepDefinition;
    'echo-rtc': typeof EchoStepDefinition;
    'rtc-peer-proxy': typeof PeerProxyStepDefinition;
    'rtc-dynamic-proxy': typeof DynamicProxyStepDefinition;
};
export {};
