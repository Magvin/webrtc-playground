"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StepLookup = exports.DynamicProxyStep = exports.PeerProxyStep = exports.EchoStep = exports.CloseStep = exports.SendStep = exports.CreateChannelStep = exports.WaitForMediaStep = exports.WaitForTrackStep = exports.WaitForMessageStep = exports.WaitForChannelStep = exports.WaitForDurationStep = void 0;
const rtc_connection_1 = require("../webrtc/rtc-connection");
const handler_step_definitions_1 = require("./handler-step-definitions");
class WaitForDurationStep extends handler_step_definitions_1.WaitForDurationStepDefinition {
    handle() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => setTimeout(resolve, this.durationMs));
        });
    }
}
exports.WaitForDurationStep = WaitForDurationStep;
class WaitForChannelStep extends handler_step_definitions_1.WaitForChannelStepDefinition {
    matchesChannel(channel) {
        return this.channelLabel === undefined || this.channelLabel === channel.label;
    }
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const channelOpened = (channel) => {
                    if (this.matchesChannel(channel)) {
                        connection.removeListener('remote-channel-open', channelOpened);
                        resolve();
                    }
                };
                connection.on('remote-channel-open', channelOpened);
                connection.remoteChannels.forEach(channelOpened);
            });
        });
    }
}
exports.WaitForChannelStep = WaitForChannelStep;
class WaitForMessageStep extends handler_step_definitions_1.WaitForMessageStepDefinition {
    matchesChannel(channel) {
        return this.channelLabel === undefined || this.channelLabel === channel.label;
    }
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const messageReceived = () => {
                    connection.removeListener('channel-created', listenForMessage);
                    connection.channels.forEach((channel) => {
                        channel.removeListener('data', messageReceived);
                        channel.pause();
                    });
                    resolve();
                };
                const listenForMessage = (channel) => {
                    if (this.matchesChannel(channel)) {
                        channel.once('data', messageReceived);
                    }
                };
                connection.on('channel-created', listenForMessage);
                connection.channels.forEach(listenForMessage);
            });
        });
    }
}
exports.WaitForMessageStep = WaitForMessageStep;
class WaitForTrackStep extends handler_step_definitions_1.WaitForTrackStepDefinition {
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                if (connection.remoteMediaTracks.length)
                    resolve();
                else
                    connection.once('remote-track-open', () => resolve());
            });
        });
    }
}
exports.WaitForTrackStep = WaitForTrackStep;
class WaitForMediaStep extends handler_step_definitions_1.WaitForMediaStepDefinition {
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const messageReceived = () => {
                    connection.removeListener('track-created', listenForData);
                    connection.mediaTracks.forEach((track) => {
                        track.removeListener('data', messageReceived);
                        track.pause();
                    });
                    resolve();
                };
                const listenForData = (track) => {
                    track.once('data', messageReceived);
                };
                connection.on('track-created', listenForData);
                connection.mediaTracks.forEach(listenForData);
            });
        });
    }
}
exports.WaitForMediaStep = WaitForMediaStep;
class CreateChannelStep extends handler_step_definitions_1.CreateChannelStepDefinition {
    handle(conn) {
        return __awaiter(this, void 0, void 0, function* () {
            const channel = conn.createDataChannel(this.channelLabel);
            return new Promise((resolve) => channel.once('channel-open', resolve));
        });
    }
}
exports.CreateChannelStep = CreateChannelStep;
class SendStep extends handler_step_definitions_1.SendStepDefinition {
    matchesChannel(channel) {
        return this.channelLabel === undefined || this.channelLabel === channel.label;
    }
    handle({ channels }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(channels
                .filter((channel) => this.matchesChannel(channel))
                .map((channel) => {
                return new Promise((resolve, reject) => {
                    channel.write(this.message, (error) => {
                        if (error)
                            reject(error);
                        else
                            resolve();
                    });
                });
            }));
        });
    }
    static deserialize(data) {
        return new SendStep(data.channelLabel, typeof data.message === 'string'
            ? data.message
            // Buffers are serialized very roughly, so here we
            // turn them back into real Buffer instances:
            : Buffer.from(data.message.data));
    }
}
exports.SendStep = SendStep;
class CloseStep extends handler_step_definitions_1.CloseStepDefinition {
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            yield connection.close();
        });
    }
}
exports.CloseStep = CloseStep;
class EchoStep extends handler_step_definitions_1.EchoStepDefinition {
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const echoContent = (stream) => {
                stream.pipe(stream);
            };
            connection.on('channel-created', echoContent);
            connection.on('track-created', echoContent);
            connection.channels.forEach(echoContent);
            connection.mediaTracks.forEach(echoContent);
            // This step keeps running indefinitely, until the connection closes
            return new Promise((resolve) => connection.on('connection-closed', resolve));
        });
    }
}
exports.EchoStep = EchoStep;
class PeerProxyStep extends handler_step_definitions_1.PeerProxyStepDefinition {
    constructor() {
        super(...arguments);
        this.externalConnections = [];
    }
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            const externalConn = new rtc_connection_1.RTCConnection();
            this.externalConnections.push(externalConn);
            // We mirror the internal peer's SDP as an offer to the given connection:
            const externalOffer = yield externalConn.getMirroredLocalOffer(connection.getRemoteDescription().sdp);
            externalConn.setRemoteDescription(yield this.getAnswer(externalOffer));
            yield connection.proxyTrafficTo(externalConn);
            // This step keeps running indefinitely, until the connection closes
            return new Promise((resolve) => connection.on('connection-closed', resolve));
        });
    }
    serialize(channel) {
        channel.onRequest((msg) => __awaiter(this, void 0, void 0, function* () {
            return { answer: yield this.getAnswer(msg.offer) };
        }));
        return { type: this.type };
    }
    static deserialize(_data, channel) {
        return new PeerProxyStep((offer) => __awaiter(this, void 0, void 0, function* () {
            const response = yield channel.request({ offer });
            return response.answer;
        }));
    }
    dispose() {
        this.externalConnections.forEach(conn => conn.close());
    }
}
exports.PeerProxyStep = PeerProxyStep;
class DynamicProxyStep extends handler_step_definitions_1.DynamicProxyStepDefinition {
    constructor() {
        super(...arguments);
        this.externalConnections = [];
    }
    handle(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            yield connection.proxyTrafficToExternalConnection();
            // This step keeps running indefinitely, until the connection closes
            return new Promise((resolve) => connection.on('connection-closed', resolve));
        });
    }
    dispose() {
        this.externalConnections.forEach(conn => conn.close());
    }
}
exports.DynamicProxyStep = DynamicProxyStep;
exports.StepLookup = {
    'wait-for-duration': WaitForDurationStep,
    'wait-for-rtc-data-channel': WaitForChannelStep,
    'wait-for-rtc-track': WaitForTrackStep,
    'wait-for-rtc-media': WaitForMediaStep,
    'wait-for-rtc-message': WaitForMessageStep,
    'create-rtc-data-channel': CreateChannelStep,
    'send-rtc-data-message': SendStep,
    'close-rtc-connection': CloseStep,
    'echo-rtc': EchoStep,
    'rtc-peer-proxy': PeerProxyStep,
    'rtc-dynamic-proxy': DynamicProxyStep
};
//# sourceMappingURL=handler-steps.js.map