"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatcherLookup = exports.UserAgentRegexMatcher = exports.UrlRegexMatcher = exports.HostnameMatcher = exports.HasMediaTrackMatcher = exports.HasAudioTrackMatcher = exports.HasVideoTrackMatcher = exports.HasDataChannelMatcher = void 0;
const matcher_definitions_1 = require("./matcher-definitions");
class HasDataChannelMatcher extends matcher_definitions_1.HasDataChannelMatcherDefinition {
    matches(connection) {
        return [
            ...connection.getLocalDescription().parsedSdp.media,
            ...connection.getRemoteDescription().parsedSdp.media
        ].some(media => media.type === 'application');
    }
}
exports.HasDataChannelMatcher = HasDataChannelMatcher;
class HasVideoTrackMatcher extends matcher_definitions_1.HasVideoTrackMatcherDefinition {
    matches(connection) {
        return [
            ...connection.getLocalDescription().parsedSdp.media,
            ...connection.getRemoteDescription().parsedSdp.media
        ].some(media => media.type === 'video');
    }
}
exports.HasVideoTrackMatcher = HasVideoTrackMatcher;
class HasAudioTrackMatcher extends matcher_definitions_1.HasAudioTrackMatcherDefinition {
    matches(connection) {
        return [
            ...connection.getLocalDescription().parsedSdp.media,
            ...connection.getRemoteDescription().parsedSdp.media
        ].some(media => media.type === 'audio');
    }
}
exports.HasAudioTrackMatcher = HasAudioTrackMatcher;
class HasMediaTrackMatcher extends matcher_definitions_1.HasMediaTrackMatcherDefinition {
    matches(connection) {
        return [
            ...connection.getLocalDescription().parsedSdp.media,
            ...connection.getRemoteDescription().parsedSdp.media
        ].some(media => media.type === 'video' || media.type === 'audio');
    }
}
exports.HasMediaTrackMatcher = HasMediaTrackMatcher;
const getConnectionSourceURL = (connection) => {
    const { sourceURL } = connection.metadata;
    if (!sourceURL)
        return;
    try {
        return new URL(sourceURL);
    }
    catch (e) {
        console.warn('Unparseable RTC source URL:', e);
        return;
    }
};
class HostnameMatcher extends matcher_definitions_1.HostnameMatcherDefinition {
    matches(connection) {
        const url = getConnectionSourceURL(connection);
        return (url === null || url === void 0 ? void 0 : url.hostname) === this.hostname;
    }
}
exports.HostnameMatcher = HostnameMatcher;
class UrlRegexMatcher extends matcher_definitions_1.UrlRegexMatcherDefinition {
    matches(connection) {
        const url = getConnectionSourceURL(connection);
        return !!(url === null || url === void 0 ? void 0 : url.toString().match(new RegExp(this.regexSource, this.regexFlags)));
    }
}
exports.UrlRegexMatcher = UrlRegexMatcher;
class UserAgentRegexMatcher extends matcher_definitions_1.UserAgentRegexMatcherDefinition {
    matches(connection) {
        const userAgent = connection.metadata.userAgent;
        return !!(userAgent === null || userAgent === void 0 ? void 0 : userAgent.match(new RegExp(this.regexSource, this.regexFlags)));
    }
}
exports.UserAgentRegexMatcher = UserAgentRegexMatcher;
exports.MatcherLookup = {
    'has-rtc-data-channel': HasDataChannelMatcher,
    'has-rtc-video-track': HasVideoTrackMatcher,
    'has-rtc-audio-track': HasAudioTrackMatcher,
    'has-rtc-media-track': HasMediaTrackMatcher,
    'rtc-page-hostname': HostnameMatcher,
    'rtc-page-regex': UrlRegexMatcher,
    'rtc-user-agent-regex': UserAgentRegexMatcher
};
//# sourceMappingURL=matchers.js.map