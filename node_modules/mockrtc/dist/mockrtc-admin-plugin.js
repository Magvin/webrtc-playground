"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCAdminPlugin = void 0;
const graphql_tag_1 = require("graphql-tag");
const serialization_1 = require("mockttp/dist/util/serialization");
const handler_steps_1 = require("./handling/handler-steps");
const mockrtc_server_1 = require("./mockrtc-server");
class MockRTCAdminPlugin {
    constructor() {
        this.schema = (0, graphql_tag_1.gql) `
        extend type Mutation {
            createPeer(data: RTCHandlerData!): MockedPeer!

            createOffer(peerId: ID!, sessionId: ID): Session!
            createExternalOffer(peerId: ID!): Session!
            completeOffer(peerId: ID!, sessionId: ID!, answer: SessionDescriptionInput!): Void

            answerOffer(peerId: ID!, sessionId: ID, offer: SessionDescriptionInput!): Session!
            answerExternalOffer(peerId: ID!, offer: SessionDescriptionInput!): Session!
            answerRenegotiationOffer(sessionId: ID!, offer: SessionDescriptionInput!): Session!
        }

        input RTCHandlerData {
            steps: [Raw!]!
        }

        type MockedPeer {
            peerId: ID!
        }

        input SessionDescriptionInput {
            type: String!
            sdp: String!
        }

        type SessionDescriptionResult {
            type: String!
            sdp: String!
        }

        type Session {
            id: ID!
            description: SessionDescriptionResult
        }

        extend type Query {
            getSeenMessages(peerId: ID!, channelName: String): [Raw!]
        }

        scalar HandlerStep
    `;
    }
    start(options) {
        this.mockRTCServer = new mockrtc_server_1.MockRTCServer(options);
        return this.mockRTCServer.start();
    }
    reset() { }
    stop() {
        return this.mockRTCServer.stop();
    }
    buildResolvers(adminStream, ruleParams) {
        return {
            Mutation: {
                createPeer: (__, { data: { steps } }) => {
                    return this.mockRTCServer.buildPeerFromData(steps.map((stepData) => (0, serialization_1.deserialize)(stepData, adminStream, ruleParams, handler_steps_1.StepLookup)));
                },
                createOffer: (__, { peerId, sessionId }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    if (sessionId) {
                        const session = peer.getSessionApi(sessionId);
                        return {
                            id: sessionId,
                            description: yield session.createOffer()
                        };
                    }
                    else {
                        const offerParams = yield peer.createOffer();
                        return { id: offerParams._sessionId, description: offerParams.offer };
                    }
                }),
                createExternalOffer: (__, { peerId }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    const offerParams = yield peer.createExternalOffer();
                    return { id: offerParams.id, description: offerParams.offer };
                }),
                completeOffer: (__, { peerId, sessionId, answer }) => __awaiter(this, void 0, void 0, function* () {
                    const session = this.mockRTCServer.getPeer(peerId).getSessionApi(sessionId);
                    yield session.completeOffer(answer);
                }),
                answerOffer: (__, { peerId, sessionId, offer }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    if (sessionId) {
                        const session = peer.getSessionApi(sessionId);
                        const answer = yield session.answerOffer(offer);
                        return { id: sessionId, description: answer };
                    }
                    else {
                        const answerParams = yield peer.answerOffer(offer);
                        return { id: answerParams._sessionId, description: answerParams.answer };
                    }
                }),
                answerExternalOffer: (__, { peerId, offer }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    const answerParams = yield peer.answerExternalOffer(offer);
                    return { id: answerParams.id, description: answerParams.answer };
                })
            },
            Query: {
                getSeenMessages: (__, { peerId, channelName }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    const messages = yield (channelName != undefined
                        ? peer.getMessagesOnChannel(channelName)
                        : peer.getAllMessages());
                    return messages.map((message) => {
                        if (Buffer.isBuffer(message)) {
                            return { type: 'buffer', value: message.toString('base64') };
                        }
                        else {
                            return message;
                        }
                    });
                })
            }
        };
    }
}
exports.MockRTCAdminPlugin = MockRTCAdminPlugin;
//# sourceMappingURL=mockrtc-admin-plugin.js.map