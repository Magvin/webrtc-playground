"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCServerPeer = void 0;
const crypto_1 = require("crypto");
const rtc_connection_1 = require("./webrtc/rtc-connection");
const mockrtc_connection_1 = require("./webrtc/mockrtc-connection");
class MockRTCServerPeer {
    constructor(handlerSteps, options = {}) {
        this.handlerSteps = handlerSteps;
        this.options = options;
        this.peerId = (0, crypto_1.randomUUID)();
        // A list of all currently open connections managed by this peer
        this.connections = {};
        // A subset of the connections: external connections with no assigned internal connection
        this.unassignedExternalConnections = {};
        this.getExternalConnection = (id) => {
            const externalConn = this.unassignedExternalConnections[id];
            if (!externalConn)
                throw new Error(`Attempted to connect unknown external conn ${id}`);
            delete this.unassignedExternalConnections[id];
            return externalConn;
        };
        this.messages = {};
    }
    trackConnection(conn) {
        this.connections[conn.id] = conn;
        conn.once('connection-closed', () => {
            delete this.connections[conn.id];
        });
    }
    createExternalOffer() {
        return __awaiter(this, void 0, void 0, function* () {
            const externalConn = new rtc_connection_1.RTCConnection();
            this.unassignedExternalConnections[externalConn.id] = externalConn;
            this.trackConnection(externalConn);
            return {
                id: externalConn.id,
                offer: yield externalConn.getLocalDescription(),
                setAnswer: (answer) => __awaiter(this, void 0, void 0, function* () {
                    externalConn.sessionApi.completeOffer(answer);
                    return externalConn.sessionApi;
                })
            };
        });
    }
    answerExternalOffer(offer) {
        return __awaiter(this, void 0, void 0, function* () {
            const externalConn = new rtc_connection_1.RTCConnection();
            const externalConnId = (0, crypto_1.randomUUID)();
            this.unassignedExternalConnections[externalConnId] = externalConn;
            this.trackConnection(externalConn);
            externalConn.setRemoteDescription(offer);
            return {
                id: externalConnId,
                answer: yield externalConn.getLocalDescription()
            };
        });
    }
    createConnection() {
        const conn = new mockrtc_connection_1.MockRTCConnection(this.getExternalConnection);
        this.trackConnection(conn);
        this.handleConnection(conn).catch((error) => {
            console.error("Error handling WebRTC connection:", error);
            conn.close().catch(() => { });
        });
        if (this.options.recordMessages) {
            conn.on('channel-open', (channel) => {
                var _a;
                var _b;
                const channelLabel = channel.label;
                const messageLog = ((_a = (_b = this.messages)[channelLabel]) !== null && _a !== void 0 ? _a : (_b[channelLabel] = []));
                channel.on('data', d => {
                    messageLog.push(d);
                });
            });
        }
        return conn;
    }
    createOffer() {
        return __awaiter(this, void 0, void 0, function* () {
            const conn = this.createConnection();
            return {
                _sessionId: conn.id,
                offer: yield conn.sessionApi.createOffer(),
                setAnswer: (answer) => __awaiter(this, void 0, void 0, function* () {
                    conn.sessionApi.completeOffer(answer);
                    return conn.sessionApi;
                })
            };
        });
    }
    answerOffer(offer) {
        return __awaiter(this, void 0, void 0, function* () {
            const conn = this.createConnection();
            const answer = yield conn.sessionApi.answerOffer(offer);
            return {
                _sessionId: conn.id,
                answer,
                session: conn.sessionApi
            };
        });
    }
    getSessionApi(id) {
        return this.connections[id].sessionApi;
    }
    handleConnection(conn) {
        return __awaiter(this, void 0, void 0, function* () {
            yield conn.waitUntilConnected();
            for (const step of this.handlerSteps) {
                yield step.handle(conn);
            }
            yield conn.close();
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(Object.values(this.connections).map(c => c.close()));
        });
    }
    getAllMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            return Object.values(this.messages).flat();
        });
    }
    getMessagesOnChannel(channelName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.messages[channelName].flat();
        });
    }
}
exports.MockRTCServerPeer = MockRTCServerPeer;
//# sourceMappingURL=mockrtc-server-peer.js.map