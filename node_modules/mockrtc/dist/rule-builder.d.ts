/// <reference types="node" />
import { MockRTCHandlerBuilder } from "./handling/handler-builder";
import { HandlerStepDefinition } from "./handling/handler-step-definitions";
import { MatcherDefinition } from "./matching/matcher-definitions";
export declare type RuleHandlerBuilder = MockRTCHandlerBuilder<void>;
/**
 * Rule builders allow you to combine sets of matchers, progressively
 * building a set of matching conditions, before defining the resulting
 * behaviour that will be applied to matching traffic.
 */
export declare class MockRTCRuleBuilder implements Omit<RuleHandlerBuilder, 'handlerSteps' | 'buildCallback'> {
    private addRuleCallback;
    constructor(addRuleCallback: (matcherDefinitions: MatcherDefinition[], handlerStepDefinitions: HandlerStepDefinition[]) => Promise<void>);
    private matchers;
    /**
     * Match RTC connections whose initial negotiation includes a data channel.
     */
    withDataChannels(): this;
    /**
     * Match RTC connections whose initial negotiation includes either an audio or video
     * media track.
     */
    withMedia(): this;
    /**
     * Match RTC connections whose initial negotiation includes a video media track
     */
    withVideo(): this;
    /**
     * Match RTC connections whose initial negotiation includes an audio media track
     */
    withAudio(): this;
    /**
     * Match RTC connections made from hooked JavaScript running on a given hostname.
     *
     * This only matches connections with explicit `sourceURL` metadata, which must be
     * either added automatically (by using the `hookAllWebRTC` or `hookWebRTCConnection`
     * methods) or manually (by providing `metadata: { sourceURL: '...' }` options
     * during mock connection setup).
     *
     * @category Matcher
     */
    fromPageHostname(hostname: string): this;
    /**
     * Match RTC connections made from hooked JavaScript running on a matching URL.
     *
     * This only matches connections with explicit `sourceURL` metadata, which must be
     * either added automatically (by using the `hookAllWebRTC` or `hookWebRTCConnection`
     * methods) or manually (by providing `metadata: { sourceURL: '...' }` options
     * during mock connection setup).
     *
     * @category Matcher
     */
    fromPageUrlMatching(urlRegex: RegExp): this;
    /**
     * Match RTC connections made by hooked JavaScript running within a browser with a
     * matching user agent string.
     *
     * This only matches connections with explicit `userAgent` metadata, which must be
     * either added automatically (by using the `hookAllWebRTC` or `hookWebRTCConnection`
     * methods) or manually (by providing `metadata: { userAgent: '...' }` options
     * during mock connection setup).
     *
     * @category Matcher
     */
    fromUserAgentMatching(userAgentRegEx: RegExp): this;
    private buildDefinitionMethod;
    sleep: (duration: number) => MockRTCHandlerBuilder<void>;
    waitForChannel: (channelLabel?: string | undefined) => MockRTCHandlerBuilder<void>;
    waitForTrack: () => MockRTCHandlerBuilder<void>;
    waitForNextMessage: () => MockRTCHandlerBuilder<void>;
    waitForNextMedia: () => MockRTCHandlerBuilder<void>;
    waitForNextMessageOnChannel: (channelLabel: string) => MockRTCHandlerBuilder<void>;
    createDataChannel: (channelLabel: string) => MockRTCHandlerBuilder<void>;
    send: {
        (message: string | Buffer): MockRTCHandlerBuilder<void>;
        (channel: string | undefined, message: string | Buffer): MockRTCHandlerBuilder<void>;
    };
    thenClose: () => Promise<void>;
    thenSend: {
        (message: string | Buffer): Promise<void>;
        (channel: string, message: string | Buffer): Promise<void>;
    };
    thenEcho: () => Promise<void>;
    thenForwardTo: (peer: RTCPeerConnection) => Promise<void>;
    thenPassThrough: () => Promise<void>;
}
