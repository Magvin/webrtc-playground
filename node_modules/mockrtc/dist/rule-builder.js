"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCRuleBuilder = void 0;
const handler_builder_1 = require("./handling/handler-builder");
const matcher_definitions_1 = require("./matching/matcher-definitions");
/**
 * Rule builders allow you to combine sets of matchers, progressively
 * building a set of matching conditions, before defining the resulting
 * behaviour that will be applied to matching traffic.
 */
class MockRTCRuleBuilder {
    constructor(addRuleCallback) {
        this.addRuleCallback = addRuleCallback;
        this.matchers = [];
        // For all handler methods, return a handler builder - i.e. once you start calling
        // any of these step-definition methods, you can't keep calling matcher methods:
        this.buildDefinitionMethod = (methodName) => ((...args) => {
            const handlerBuilder = new handler_builder_1.MockRTCHandlerBuilder((steps) => this.addRuleCallback(this.matchers, steps));
            return handlerBuilder[methodName](...args);
        });
        this.sleep = this.buildDefinitionMethod('sleep');
        this.waitForChannel = this.buildDefinitionMethod('waitForChannel');
        this.waitForTrack = this.buildDefinitionMethod('waitForTrack');
        this.waitForNextMessage = this.buildDefinitionMethod('waitForNextMessage');
        this.waitForNextMedia = this.buildDefinitionMethod('waitForNextMedia');
        this.waitForNextMessageOnChannel = this.buildDefinitionMethod('waitForNextMessageOnChannel');
        this.createDataChannel = this.buildDefinitionMethod('createDataChannel');
        this.send = this.buildDefinitionMethod('send');
        this.thenClose = this.buildDefinitionMethod('thenClose');
        this.thenSend = this.buildDefinitionMethod('thenSend');
        this.thenEcho = this.buildDefinitionMethod('thenEcho');
        this.thenForwardTo = this.buildDefinitionMethod('thenForwardTo');
        this.thenPassThrough = this.buildDefinitionMethod('thenPassThrough');
    }
    /**
     * Match RTC connections whose initial negotiation includes a data channel.
     */
    withDataChannels() {
        this.matchers.push(new matcher_definitions_1.HasDataChannelMatcherDefinition());
        return this;
    }
    /**
     * Match RTC connections whose initial negotiation includes either an audio or video
     * media track.
     */
    withMedia() {
        this.matchers.push(new matcher_definitions_1.HasMediaTrackMatcherDefinition());
        return this;
    }
    /**
     * Match RTC connections whose initial negotiation includes a video media track
     */
    withVideo() {
        this.matchers.push(new matcher_definitions_1.HasVideoTrackMatcherDefinition());
        return this;
    }
    /**
     * Match RTC connections whose initial negotiation includes an audio media track
     */
    withAudio() {
        this.matchers.push(new matcher_definitions_1.HasAudioTrackMatcherDefinition());
        return this;
    }
    /**
     * Match RTC connections made from hooked JavaScript running on a given hostname.
     *
     * This only matches connections with explicit `sourceURL` metadata, which must be
     * either added automatically (by using the `hookAllWebRTC` or `hookWebRTCConnection`
     * methods) or manually (by providing `metadata: { sourceURL: '...' }` options
     * during mock connection setup).
     *
     * @category Matcher
     */
    fromPageHostname(hostname) {
        this.matchers.push(new matcher_definitions_1.HostnameMatcherDefinition(hostname));
        return this;
    }
    /**
     * Match RTC connections made from hooked JavaScript running on a matching URL.
     *
     * This only matches connections with explicit `sourceURL` metadata, which must be
     * either added automatically (by using the `hookAllWebRTC` or `hookWebRTCConnection`
     * methods) or manually (by providing `metadata: { sourceURL: '...' }` options
     * during mock connection setup).
     *
     * @category Matcher
     */
    fromPageUrlMatching(urlRegex) {
        this.matchers.push(new matcher_definitions_1.UrlRegexMatcherDefinition(urlRegex));
        return this;
    }
    /**
     * Match RTC connections made by hooked JavaScript running within a browser with a
     * matching user agent string.
     *
     * This only matches connections with explicit `userAgent` metadata, which must be
     * either added automatically (by using the `hookAllWebRTC` or `hookWebRTCConnection`
     * methods) or manually (by providing `metadata: { userAgent: '...' }` options
     * during mock connection setup).
     *
     * @category Matcher
     */
    fromUserAgentMatching(userAgentRegEx) {
        this.matchers.push(new matcher_definitions_1.UserAgentRegexMatcherDefinition(userAgentRegEx));
        return this;
    }
}
exports.MockRTCRuleBuilder = MockRTCRuleBuilder;
//# sourceMappingURL=rule-builder.js.map