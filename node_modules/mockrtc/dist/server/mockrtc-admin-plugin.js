"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCAdminPlugin = void 0;
const _ = require("lodash");
const graphql_tag_1 = require("graphql-tag");
const mockttp_1 = require("mockttp");
const graphql_subscriptions_1 = require("graphql-subscriptions");
const handler_steps_1 = require("../handling/handler-steps");
const mockrtc_server_1 = require("./mockrtc-server");
const matchers_1 = require("../matching/matchers");
const { deserialize } = mockttp_1.PluggableAdmin.Serialization;
const EVENTS = [
    'peer-connected',
    'peer-disconnected',
    'external-peer-attached',
    'data-channel-opened',
    'data-channel-message-sent',
    'data-channel-message-received',
    'data-channel-closed',
    'media-track-opened',
    'media-track-stats',
    'media-track-closed'
];
class MockRTCAdminPlugin {
    constructor() {
        this.schema = (0, graphql_tag_1.gql) `
        extend type Mutation {
            createPeer(data: RTCHandlerData!): MockedPeer!
            addRTCRule(data: RTCRuleData!): Void
            setRTCRules(data: [RTCRuleData!]!): Void

            createOffer(peerId: ID!, sessionId: ID, options: Raw): Session!
            createExternalOffer(peerId: ID!, options: Raw): Session!
            completeOffer(peerId: ID!, sessionId: ID!, answer: SessionDescriptionInput!): Void

            answerOffer(peerId: ID!, sessionId: ID, offer: SessionDescriptionInput!, options: Raw): Session!
            answerExternalOffer(peerId: ID!, offer: SessionDescriptionInput!, options: Raw): Session!
        }

        input RTCHandlerData {
            steps: [Raw!]!
        }

        input RTCRuleData {
            matchers: [Raw!]!
            steps: [Raw!]!
        }

        type MockedPeer {
            peerId: ID!
        }

        input SessionDescriptionInput {
            type: String!
            sdp: String!
        }

        type SessionDescriptionResult {
            type: String!
            sdp: String!
        }

        type Session {
            id: ID!
            description: SessionDescriptionResult
        }

        extend type Query {
            getSeenMessages(peerId: ID!, channelName: String): [Raw!]
        }

        scalar HandlerStep

        extend type Subscription {
            peerConnected: RTCPeerConnectionEvent!
            peerDisconnected: RTCPeerDisconnectionEvent!
            externalPeerAttached: RTCAttachmentEvent!

            dataChannelOpened: DataChannelOpenEvent!
            dataChannelMessageSent: DataChannelMessageEvent!
            dataChannelMessageReceived: DataChannelMessageEvent!
            dataChannelClosed: DataChannelCloseEvent!

            mediaTrackOpened: MediaTrackOpenEvent!
            mediaTrackStats: MediaTrackStatsEvent!
            mediaTrackClosed: MediaTrackCloseEvent!
        }

        type RTCPeerConnectionEvent {
            peerId: ID!
            sessionId: ID!

            metadata: Raw!
            timingEvents: Raw!

            localSessionDescription: SessionDescriptionResult!
            remoteSessionDescription: SessionDescriptionResult!
            selectedLocalCandidate: RTCSelectedCandidate!
            selectedRemoteCandidate: RTCSelectedCandidate!
        }

        type RTCSelectedCandidate {
            address: String!
            port: Int!
            protocol: String!
            type: String!
        }

        type RTCPeerDisconnectionEvent {
            peerId: ID!
            sessionId: ID!
            timingEvents: Raw!
        }

        type RTCAttachmentEvent {
            peerId: ID!
            sessionId: ID!
            externalConnection: RTCExternalPeerConnectionEvent!
            timingEvents: Raw!
        }

        type RTCExternalPeerConnectionEvent {
            sessionId: ID!
            localSessionDescription: SessionDescriptionResult!
            remoteSessionDescription: SessionDescriptionResult!
            selectedLocalCandidate: RTCSelectedCandidate!
            selectedRemoteCandidate: RTCSelectedCandidate!
        }

        type DataChannelOpenEvent {
            peerId: ID!
            sessionId: ID!
            channelId: Int!
            channelLabel: String!
            channelProtocol: String!

            eventTimestamp: Float!
            timingEvents: Raw!
        }

        type DataChannelMessageEvent {
            peerId: ID!
            sessionId: ID!
            channelId: Int!
            direction: String!
            content: Buffer!
            isBinary: Boolean!

            eventTimestamp: Float!
            timingEvents: Raw!
        }

        type DataChannelCloseEvent {
            peerId: ID!
            sessionId: ID!
            channelId: Int!

            eventTimestamp: Float!
            timingEvents: Raw!
        }

        type MediaTrackOpenEvent {
            peerId: ID!
            sessionId: ID!
            trackMid: ID!
            trackType: String!
            trackDirection: String!

            eventTimestamp: Float!
            timingEvents: Raw!
        }

        type MediaTrackStatsEvent {
            peerId: ID!
            sessionId: ID!
            trackMid: ID!

            totalBytesSent: Int!
            totalBytesReceived: Int!

            eventTimestamp: Float!
            timingEvents: Raw!
        }

        type MediaTrackCloseEvent {
            peerId: ID!
            sessionId: ID!
            trackMid: ID!

            eventTimestamp: Float!
            timingEvents: Raw!
        }
    `;
    }
    start(options) {
        this.mockRTCServer = new mockrtc_server_1.MockRTCServer(options);
        return this.mockRTCServer.start();
    }
    reset() {
        this.mockRTCServer.reset();
    }
    stop() {
        return this.mockRTCServer.stop();
    }
    buildResolvers(adminStream, ruleParams) {
        const pubsub = new graphql_subscriptions_1.PubSub();
        EVENTS.forEach((eventName) => {
            this.mockRTCServer.on(eventName, (peer) => {
                pubsub.publish(eventName, { [_.camelCase(eventName)]: peer });
            });
        });
        return {
            Mutation: {
                createPeer: (__, { data: { steps } }) => {
                    return this.mockRTCServer.buildPeerFromDefinition(steps.map((stepData) => deserialize(stepData, adminStream, ruleParams, handler_steps_1.StepLookup)));
                },
                addRTCRule: (__, { data: { steps, matchers } }) => {
                    return this.mockRTCServer.addRuleFromDefinition(matchers.map((matcherData) => deserialize(matcherData, adminStream, ruleParams, matchers_1.MatcherLookup)), steps.map((stepData) => deserialize(stepData, adminStream, ruleParams, handler_steps_1.StepLookup)));
                },
                setRTCRules: (__, { data: rules }) => {
                    return this.mockRTCServer.setRulesFromDefinitions(rules.map(({ matchers, steps }) => ({
                        matchers: matchers.map((matcherData) => deserialize(matcherData, adminStream, ruleParams, matchers_1.MatcherLookup)),
                        steps: steps.map((stepData) => deserialize(stepData, adminStream, ruleParams, handler_steps_1.StepLookup))
                    })));
                },
                createOffer: (__, { peerId, sessionId, options }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    if (sessionId) {
                        const session = peer.getSession(sessionId);
                        return {
                            id: sessionId,
                            description: yield session.createOffer(options)
                        };
                    }
                    else {
                        const offerParams = yield peer.createOffer(options);
                        return {
                            id: offerParams.session.sessionId,
                            description: offerParams.offer
                        };
                    }
                }),
                createExternalOffer: (__, { peerId, options }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    const offerParams = yield peer.createExternalOffer(options);
                    return {
                        id: offerParams.id,
                        description: offerParams.offer
                    };
                }),
                completeOffer: (__, { peerId, sessionId, answer }) => __awaiter(this, void 0, void 0, function* () {
                    const session = this.mockRTCServer.getPeer(peerId).getSession(sessionId);
                    yield session.completeOffer(answer);
                }),
                answerOffer: (__, { peerId, sessionId, offer, options }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    if (sessionId) {
                        const session = peer.getSession(sessionId);
                        const answer = yield session.answerOffer(offer, options);
                        return { id: sessionId, description: answer };
                    }
                    else {
                        const answerParams = yield peer.answerOffer(offer, options);
                        return {
                            id: answerParams.session.sessionId,
                            description: answerParams.answer
                        };
                    }
                }),
                answerExternalOffer: (__, { peerId, offer, options }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    const answerParams = yield peer.answerExternalOffer(offer, options);
                    return {
                        id: answerParams.id,
                        description: answerParams.answer
                    };
                })
            },
            Query: {
                getSeenMessages: (__, { peerId, channelName }) => __awaiter(this, void 0, void 0, function* () {
                    const peer = this.mockRTCServer.getPeer(peerId);
                    if (!peer)
                        throw new Error("Id matches no active peer");
                    const messages = yield (channelName != undefined
                        ? peer.getMessagesOnChannel(channelName)
                        : peer.getAllMessages());
                    return messages.map((message) => {
                        if (Buffer.isBuffer(message)) {
                            return { type: 'buffer', value: message.toString('base64') };
                        }
                        else {
                            return message;
                        }
                    });
                })
            },
            Subscription: Object.assign({}, (EVENTS.reduce((acc, eventName) => (Object.assign(Object.assign({}, acc), { [_.camelCase(eventName)]: {
                    subscribe: () => pubsub.asyncIterator(eventName)
                } })), {})))
        };
    }
}
exports.MockRTCAdminPlugin = MockRTCAdminPlugin;
//# sourceMappingURL=mockrtc-admin-plugin.js.map