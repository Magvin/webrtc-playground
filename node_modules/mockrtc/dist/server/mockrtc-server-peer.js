"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCServerPeer = void 0;
const crypto_1 = require("crypto");
const now = require("performance-now");
const rtc_connection_1 = require("../webrtc/rtc-connection");
const mockrtc_connection_1 = require("../webrtc/mockrtc-connection");
class MockRTCServerPeer {
    constructor(getHandlerSteps, options = {}, eventEmitter) {
        this.getHandlerSteps = getHandlerSteps;
        this.options = options;
        this.eventEmitter = eventEmitter;
        this.peerId = (0, crypto_1.randomUUID)();
        this.debug = false;
        // A list of all currently open connections managed by this peer
        this.connections = {};
        // A subset of the connections: external connections with no assigned internal connection
        this.unassignedExternalConnections = {};
        this.getExternalConnection = (id) => {
            const externalConn = this.unassignedExternalConnections[id];
            if (!externalConn)
                throw new Error(`Attempted to connect unknown external conn ${id}`);
            delete this.unassignedExternalConnections[id];
            return externalConn;
        };
        this.messages = {};
        this.debug = !!options.debug;
        if (options.peerId)
            this.peerId = options.peerId;
    }
    trackConnection(conn) {
        this.connections[conn.id] = conn;
        conn.once('connection-closed', () => {
            delete this.connections[conn.id];
        });
        if (conn instanceof mockrtc_connection_1.MockRTCConnection) {
            // Here we listen to the various internal connection events, and convert them into
            // their corresponding public-API events.
            conn.once('connection-connected', () => {
                const timingEvents = {
                    startTime: Date.now(),
                    connectTimestamp: now()
                };
                const connectionEventParams = {
                    peerId: this.peerId,
                    sessionId: conn.id,
                    timingEvents
                };
                const selectedCandidates = conn.getSelectedCandidates();
                this.eventEmitter.emit('peer-connected', Object.assign(Object.assign({}, connectionEventParams), { localSessionDescription: conn.getLocalDescription(), remoteSessionDescription: conn.getRemoteDescription(), metadata: conn.metadata, selectedLocalCandidate: selectedCandidates.local, selectedRemoteCandidate: selectedCandidates.remote }));
                conn.once('external-connection-attached', (externalConn) => {
                    timingEvents.externalAttachTimestamp = now();
                    const selectedExternalCandidates = externalConn.getSelectedCandidates();
                    this.eventEmitter.emit('external-peer-attached', Object.assign(Object.assign({}, connectionEventParams), { externalConnection: {
                            sessionId: externalConn.id,
                            localSessionDescription: externalConn.getLocalDescription(),
                            remoteSessionDescription: externalConn.getRemoteDescription(),
                            selectedLocalCandidate: selectedExternalCandidates.local,
                            selectedRemoteCandidate: selectedExternalCandidates.remote
                        } }));
                });
                const emitChannelEvents = (channelStream) => {
                    const channelEventParams = Object.assign(Object.assign({}, connectionEventParams), { channelId: channelStream.id });
                    const announceOpen = () => {
                        this.eventEmitter.emit('data-channel-opened', Object.assign(Object.assign({}, channelEventParams), { channelLabel: channelStream.label, channelProtocol: channelStream.protocol, eventTimestamp: now() }));
                    };
                    if (channelStream.isOpen)
                        announceOpen();
                    else
                        channelStream.on('channel-open', announceOpen);
                    const emitMessage = (direction) => (data) => {
                        const isBinary = Buffer.isBuffer(data);
                        const content = isBinary
                            ? data
                            : Buffer.from(data, 'utf8');
                        this.eventEmitter.emit(`data-channel-message-${direction}`, Object.assign(Object.assign({}, channelEventParams), { direction,
                            content,
                            isBinary, eventTimestamp: now() }));
                    };
                    channelStream.on('read-data', emitMessage('received'));
                    channelStream.on('wrote-data', emitMessage('sent'));
                    channelStream.on('close', () => this.eventEmitter.emit('data-channel-closed', Object.assign(Object.assign({}, channelEventParams), { eventTimestamp: now() })));
                };
                conn.on('channel-created', emitChannelEvents);
                // Due to race conditions somewhere (?) presumably in node-datachannel, channels can
                // be created before the 'connected' event fires, so we need to handle already
                // existing channels here too:
                conn.channels.forEach(emitChannelEvents);
                const emitTrackEvents = (mediaTrack) => {
                    const trackEventParams = Object.assign(Object.assign({}, connectionEventParams), { trackMid: mediaTrack.mid });
                    const announceOpen = () => {
                        this.eventEmitter.emit('media-track-opened', Object.assign(Object.assign({}, trackEventParams), { trackType: mediaTrack.type, trackDirection: mediaTrack.direction, eventTimestamp: now() }));
                    };
                    if (mediaTrack.isOpen)
                        announceOpen();
                    else
                        mediaTrack.on('track-open', announceOpen);
                    let previousBytesSent = 0;
                    let previousBytesReceived = 0;
                    const statsInterval = setInterval(() => {
                        if (previousBytesSent === mediaTrack.totalBytesSent &&
                            previousBytesReceived === mediaTrack.totalBytesReceived)
                            return; // Skip zero-change events to limit traffic noise
                        this.eventEmitter.emit('media-track-stats', Object.assign(Object.assign({}, trackEventParams), { totalBytesSent: mediaTrack.totalBytesSent, totalBytesReceived: mediaTrack.totalBytesReceived, eventTimestamp: now() }));
                        previousBytesSent = mediaTrack.totalBytesSent;
                        previousBytesReceived = mediaTrack.totalBytesReceived;
                    }, 1000);
                    mediaTrack.on('close', () => {
                        clearInterval(statsInterval);
                        this.eventEmitter.emit('media-track-closed', Object.assign(Object.assign({}, trackEventParams), { eventTimestamp: now() }));
                    });
                };
                conn.on('track-created', emitTrackEvents);
                // Due to race conditions somewhere (?) presumably in node-datachannel, tracks can
                // be created before the 'connected' event fires, so we need to handle already
                // existing tracks here too:
                conn.mediaTracks.forEach(emitTrackEvents);
                conn.once('connection-closed', () => {
                    timingEvents.disconnectTimestamp = now();
                    this.eventEmitter.emit('peer-disconnected', Object.assign({}, connectionEventParams));
                });
            });
        }
    }
    createExternalOffer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Creating external peer offer for ${this.peerId}`);
            const externalConn = new rtc_connection_1.RTCConnection();
            this.unassignedExternalConnections[externalConn.id] = externalConn;
            this.trackConnection(externalConn);
            return {
                id: externalConn.id,
                offer: yield externalConn.sessionApi.createOffer(options),
                session: externalConn.sessionApi,
                setAnswer: (answer) => __awaiter(this, void 0, void 0, function* () {
                    if (this.debug)
                        console.log(`Accepting answer for external peer offer for ${this.peerId}`);
                    externalConn.sessionApi.completeOffer(answer);
                })
            };
        });
    }
    answerExternalOffer(offer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Answering offer with external peer for ${this.peerId}`);
            const externalConn = new rtc_connection_1.RTCConnection();
            this.unassignedExternalConnections[externalConn.id] = externalConn;
            this.trackConnection(externalConn);
            return {
                id: externalConn.id,
                answer: yield externalConn.sessionApi.answerOffer(offer, options),
                session: externalConn.sessionApi
            };
        });
    }
    createConnection() {
        const conn = new mockrtc_connection_1.MockRTCConnection(this.getExternalConnection);
        this.trackConnection(conn);
        this.handleConnection(conn).catch((error) => {
            console.error("Error handling WebRTC connection:", error);
            conn.close().catch(() => { });
        });
        if (this.options.recordMessages) {
            const logChannelMessages = (channel) => {
                var _a;
                var _b;
                const channelLabel = channel.label;
                const messageLog = ((_a = (_b = this.messages)[channelLabel]) !== null && _a !== void 0 ? _a : (_b[channelLabel] = []));
                channel.on('read-data', d => {
                    messageLog.push(d);
                });
            };
            conn.channels.forEach(logChannelMessages);
            conn.on('channel-created', logChannelMessages);
        }
        return conn;
    }
    createOffer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Creating mock offer for ${this.peerId}`);
            const conn = this.createConnection();
            return {
                offer: yield conn.sessionApi.createOffer(options),
                session: conn.sessionApi,
                setAnswer: (answer) => __awaiter(this, void 0, void 0, function* () {
                    conn.sessionApi.completeOffer(answer);
                })
            };
        });
    }
    answerOffer(offer, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log(`Answering offer for mocking for ${this.peerId}`);
            const conn = this.createConnection();
            return {
                answer: yield conn.sessionApi.answerOffer(offer, options),
                session: conn.sessionApi
            };
        });
    }
    getSession(id) {
        return this.connections[id].sessionApi;
    }
    handleConnection(conn) {
        return __awaiter(this, void 0, void 0, function* () {
            yield conn.waitUntilConnected();
            const handlerSteps = yield this.getHandlerSteps(conn);
            for (const step of handlerSteps) {
                yield step.handle(conn);
            }
            yield conn.close();
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(Object.values(this.connections).map(c => c.close()));
        });
    }
    getAllMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.options.recordMessages) {
                throw new Error("Can't query messages, as recordMessages was not enabled");
            }
            return Object.values(this.messages).flat();
        });
    }
    getMessagesOnChannel(channelName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.options.recordMessages) {
                throw new Error("Can't query messages, as recordMessages was not enabled");
            }
            return this.messages[channelName].flat();
        });
    }
}
exports.MockRTCServerPeer = MockRTCServerPeer;
//# sourceMappingURL=mockrtc-server-peer.js.map