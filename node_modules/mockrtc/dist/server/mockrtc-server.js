"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCServer = void 0;
const events_1 = require("events");
const mockrtc_base_1 = require("../mockrtc-base");
const mockrtc_server_peer_1 = require("./mockrtc-server-peer");
const matchers_1 = require("../matching/matchers");
const handler_steps_1 = require("../handling/handler-steps");
const MATCHING_PEER_ID = 'matching-peer';
class MockRTCServer extends mockrtc_base_1.MockRTCBase {
    constructor(options = {}) {
        super();
        this.options = options;
        this.debug = false;
        this.eventEmitter = new events_1.EventEmitter();
        this._activePeers = {};
        this.rules = [];
        this.debug = !!options.debug;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log("Starting MockRTC mock session");
            this.matchingPeer = this._activePeers[MATCHING_PEER_ID] = new mockrtc_server_peer_1.MockRTCServerPeer(this.matchConnection.bind(this), Object.assign(Object.assign({}, this.options), { peerId: MATCHING_PEER_ID }), this.eventEmitter);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log("Stopping MockRTC mock session");
            yield this.reset();
        });
    }
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.activePeers.map(peer => peer.close()));
            this._activePeers = {};
            this.matchingPeer = undefined;
            this.rules = [];
            this.eventEmitter.removeAllListeners();
        });
    }
    get activePeers() {
        return Object.values(this._activePeers);
    }
    getPeer(id) {
        return this._activePeers[id];
    }
    on(event, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            this.eventEmitter.on(event, callback);
        });
    }
    getMatchingPeer() {
        if (!this.matchingPeer) {
            throw new Error('Cannot get matching peer as the mock session is not started');
        }
        return this.matchingPeer;
    }
    setRulesFromDefinitions(rules) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rules = [];
            yield Promise.all(rules.map(({ matchers, steps }) => this.addRuleFromDefinition(matchers, steps)));
        });
    }
    addRuleFromDefinition(matcherDefinitions, handlerStepDefinitions) {
        return __awaiter(this, void 0, void 0, function* () {
            const matchers = matcherDefinitions.map((definition) => {
                return Object.assign(Object.create(matchers_1.MatcherLookup[definition.type].prototype), definition);
            });
            const handlerSteps = handlerStepDefinitions.map((definition) => {
                return Object.assign(Object.create(handler_steps_1.StepLookup[definition.type].prototype), definition);
            });
            this.rules.push({ matchers, handlerSteps });
        });
    }
    matchConnection(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug)
                console.log('Matching incoming RTC connection...');
            yield connection.waitUntilConnected();
            for (const rule of this.rules) {
                const matches = rule.matchers.every(matcher => matcher.matches(connection));
                if (matches) {
                    if (this.debug)
                        console.log(`Matched incoming RTC connection, running steps: ${rule.handlerSteps.map(s => s.type).join(', ')}`);
                    return rule.handlerSteps;
                }
            }
            if (this.debug)
                console.log('RTC connection did not match any rules');
            // Unmatched connections are proxied dynamically. In practice, that means they're accepted
            // and ignored initially, unless an external peer also connects and is attached:
            return [new handler_steps_1.DynamicProxyStep()];
        });
    }
    // Peer definition API:
    buildPeerFromDefinition(handlerStepDefinitions) {
        return __awaiter(this, void 0, void 0, function* () {
            const handlerSteps = handlerStepDefinitions.map((definition) => {
                return Object.assign(Object.create(handler_steps_1.StepLookup[definition.type].prototype), definition);
            });
            const peer = new mockrtc_server_peer_1.MockRTCServerPeer(() => handlerSteps, // Always runs a fixed set of steps
            this.options, this.eventEmitter);
            this._activePeers[peer.peerId] = peer;
            if (this.debug)
                console.log(`Built MockRTC peer ${peer.peerId} with steps: ${handlerStepDefinitions.map(d => d.type).join(', ')}`);
            return peer;
        });
    }
}
exports.MockRTCServer = MockRTCServer;
//# sourceMappingURL=mockrtc-server.js.map