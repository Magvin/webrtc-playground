"use strict";
// export interface MockRTC {
//     /**
//      * Start creating a mock WebRTC peer. This method returns a builder, who
//      * must be configured with the mock peer's settings. Once configured the
//      * peer can be created by calling any `.thenX()` method to define the
//      * peer's behaviour.
//      */
//     buildPeer(): MockRTCPeerBuilder;
//     /**
//      * Start defining a WebRTC mock rule. This method returns a builder, who
//      * must be configured with the rule's settings, to define which peers
//      * it matches and what it does next. Once configured, the rule can be
//      * created by calling any `.thenX()` method.
//      */
//     forAnyConnection(): MockRTCRuleBuilder
//     forConnectionsTo(peerCandidate: RTCIceCandidateInit): MockRTCRuleBuilder;
//     forConnectionsTo(peerAddress: string): MockRTCRuleBuilder;
//     /**
//      * Get the connection parameters to make a direct connection to the MockRTC
//      * server, rather than connecting to a specific mock peer. When connecting
//      * like this, the connection will be matched against defined rules to decide
//      * how it should be handled.
//      *
//      * In some cases (to match real destination addresses and/or proxy traffic)
//      * the server will need metadata from the client. To provide this, the client
//      * should create a "tech.httptoolkit.webrtc.control" data channel and post
//      * the metadata before creating any other channels or media tracks.
//      */
//     getDirectConnectionParameters(offer: RTCSessionDescriptionInit): Promise<MockRTCConnectionParams>;
// }
// export interface MockRTCConnectionParams {
//     iceCandidate: RTCIceCandidateInit;
//     sessionDescription: RTCSessionDescriptionInit;
// }
// /**
//  * The builder logic for composing RTC handling behaviour for both mock peers and rules,
//  * by internally queuing defined actions until a `.thenX()` method is called to compile
//  * the actions into either a peer or a rule (handled by an abstract method).
//  */
// export abstract class MockRTCHandlingBuilder<R> {
//     abstract build(): R;
//     waitForMessage(): this;
//     thenReply(): R;
// }
// /**
//  * Used to build mock peers, which respond to all connections in a configurable way.
//  */
// export class MockRTCPeerBuilder extends MockRTCHandlingBuilder<MockRTCPeer> {
//     build() {
//         return new MockRTCPeer();
//     }
// }
// /**
//  * Used to build mock rules which match incoming connections and then respond to
//  * them, in a configurable way.
//  */
// export class MockRTCRuleBuilder extends MockRTCHandlingBuilder<MockRTCRule> {
//     // TODO: Eventually add logic to match certain peers here, and/or completion checking
// }
// export class MockRTCPeer {
//     getPeerConnectionParams(offer: RTCSessionDescriptionInit): Promise<MockRTCConnectionParams> {
//     }
// }
//# sourceMappingURL=mockrtc.js.map