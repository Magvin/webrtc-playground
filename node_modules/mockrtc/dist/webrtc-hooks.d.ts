import type { MockRTCPeer } from "./mockrtc-peer";
/**
 * Hooks a given RTCPeerConnection so that all connections it creates are automatically proxied
 * through the given MockRTCPeer.
 *
 * This allows you to capture traffic without modifying your WebRTC code: you can create
 * offers/answers and signal them to a remote client as normal, and both the local and remote
 * connections will connect to MockRTC instead.
 *
 * What happens once they connect depends on the configuration of the given peer. This mocked
 * local connection will follow the steps defined by the peer, so may receive mocked messages
 * injected there, or delays, or anything else. The remote peer will receive nothing until
 * a proxy step is reached (if ever), at which point the local & remote peers will be able to
 * talking directly, although all traffic will still be proxied through MockRTC for logging
 * and analysis/validation elsewhere.
 *
 * It is possible to proxy both real peers in a connection, potentially with different mock
 * peers so that they experience different behaviours during the connection.
 *
 * @category API
 */
export declare function hookWebRTCConnection(conn: RTCPeerConnection, mockPeer: MockRTCPeer): void;
/**
 * Modifies the global RTCPeerConnection constructor to hook all WebRTC connections
 * created after this function is called, and redirect all their traffic to the
 * provided MockRTCPeer.
 *
 * @category API
 */
export declare function hookAllWebRTC(mockPeer: MockRTCPeer): void;
