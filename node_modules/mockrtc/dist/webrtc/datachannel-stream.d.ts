/// <reference types="node" />
import * as stream from 'stream';
import type * as NodeDataChannel from 'node-datachannel';
/**
 * Turns a node-datachannel DataChannel into a real Node.js stream, complete with
 * buffering, backpressure (up to a point - if the buffer fills up, messages are dropped),
 * and support for piping data elsewhere.
 *
 * Read & written data may be either UTF-8 strings or Buffers - this difference exists at
 * the protocol level, and is preserved here throughout.
 */
export declare class DataChannelStream extends stream.Duplex {
    private rawChannel;
    constructor(rawChannel: NodeDataChannel.DataChannel, streamOptions?: {
        readableHighWaterMark?: number | undefined;
        writableHighWaterMark?: number | undefined;
        allowHalfOpen?: boolean;
    });
    private _isOpen;
    get isOpen(): boolean;
    private _readActive;
    _read(): void;
    _write(chunk: string | Buffer | unknown, encoding: string, callback: (error: Error | null) => void): void;
    _final(callback: (error: Error | null) => void): void;
    _destroy(maybeErr: Error | null, callback: (error: Error | null) => void): void;
    get id(): number;
    get label(): string;
    get protocol(): string;
}
