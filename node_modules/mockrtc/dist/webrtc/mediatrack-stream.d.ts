/// <reference types="node" />
import * as stream from 'stream';
import type * as NodeDataChannel from 'node-datachannel';
/**
 * Turns a node-datachannel media track into a real Node.js stream, complete with
 * buffering, backpressure (up to a point - if the buffer fills up, messages are dropped),
 * and support for piping data elsewhere.
 */
export declare class MediaTrackStream extends stream.Duplex {
    private rawTrack;
    constructor(rawTrack: NodeDataChannel.Track, streamOptions?: {
        readableHighWaterMark?: number | undefined;
        writableHighWaterMark?: number | undefined;
        allowHalfOpen?: boolean;
    });
    private _isOpen;
    get isOpen(): boolean;
    private _totalBytesSent;
    get totalBytesSent(): number;
    private _totalBytesReceived;
    get totalBytesReceived(): number;
    private close;
    private _readActive;
    _read(): void;
    _write(chunk: Buffer, _encoding: string, callback: (error: Error | null) => void): void;
    _writev(chunks: Array<{
        chunk: any;
        encoding: BufferEncoding;
    }>, callback: (error?: Error | null) => void): void;
    _final(callback: (error: Error | null) => void): void;
    _destroy(maybeErr: Error | null, callback: (error: Error | null) => void): void;
    get direction(): NodeDataChannel.Direction;
    get mid(): string;
    get type(): string;
}
