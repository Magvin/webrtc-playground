"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaTrackStream = void 0;
const stream = require("stream");
/**
 * Turns a node-datachannel media track into a real Node.js stream, complete with
 * buffering, backpressure (up to a point - if the buffer fills up, messages are dropped),
 * and support for piping data elsewhere.
 */
class MediaTrackStream extends stream.Duplex {
    constructor(rawTrack, streamOptions = {}) {
        super(Object.assign({ allowHalfOpen: false }, streamOptions));
        this.rawTrack = rawTrack;
        this._isOpen = false;
        this._totalBytesSent = 0;
        this._totalBytesReceived = 0;
        this._readActive = true;
        rawTrack.onMessage((msg) => {
            this._totalBytesReceived += msg.byteLength;
            if (!this._readActive)
                return; // If the buffer is full, drop messages.
            // If the push is rejected, we pause reading until the next call to _read().
            this._readActive = this.push(msg);
        });
        // When the DataChannel closes, the readable & writable ends close
        rawTrack.onClosed(() => this.close());
        rawTrack.onError((errMsg) => {
            this.destroy(new Error(`Media track error: ${errMsg}`));
        });
        // Buffer all writes until the DataChannel opens
        if (!rawTrack.isOpen()) {
            this.cork();
            rawTrack.onOpen(() => {
                this.uncork();
                this._isOpen = true;
                this.emit('track-open');
            });
        }
        else {
            setImmediate(() => {
                this._isOpen = true;
                this.emit('track-open');
            });
        }
    }
    get isOpen() {
        return this._isOpen;
    }
    get totalBytesSent() {
        return this._totalBytesSent;
    }
    get totalBytesReceived() {
        return this._totalBytesReceived;
    }
    close() {
        this.push(null);
        this.destroy();
    }
    _read() {
        // Stop dropping messages, if the buffer filling up meant we were doing so before.
        this._readActive = true;
    }
    _write(chunk, _encoding, callback) {
        let sentOk;
        if (this.rawTrack.isClosed()) {
            // isClosed becomes true and writes start failing just before onClosed() fires, so here we
            // drop pending writes as soon as we notice.
            this.close();
            return;
        }
        try {
            sentOk = this.rawTrack.sendMessageBinary(chunk);
            this._totalBytesSent += chunk.byteLength;
        }
        catch (err) {
            return callback(err);
        }
        if (sentOk) {
            callback(null);
        }
        else {
            callback(new Error("Failed to write to media track"));
        }
    }
    _writev(chunks, callback) {
        let sentOk;
        if (this.rawTrack.isClosed()) {
            // isClosed becomes true and writes start failing just before onClosed() fires, so here we
            // drop pending writes as soon as we notice.
            this.close();
            return;
        }
        try {
            const combinedChunks = Buffer.concat(chunks.map(c => c.chunk));
            sentOk = this.rawTrack.sendMessageBinary(combinedChunks);
            this._totalBytesSent += combinedChunks.byteLength;
        }
        catch (err) {
            return callback(err);
        }
        if (sentOk) {
            callback(null);
        }
        else {
            callback(new Error("Failed to write to media track"));
        }
    }
    _final(callback) {
        if (!this.allowHalfOpen)
            this.destroy();
        callback(null);
    }
    _destroy(maybeErr, callback) {
        // When the stream is destroyed, we close the DataChannel.
        this.rawTrack.close();
        callback(maybeErr);
    }
    get direction() {
        return this.rawTrack.direction();
    }
    get mid() {
        return this.rawTrack.mid();
    }
    get type() {
        return this.rawTrack.type();
    }
}
exports.MediaTrackStream = MediaTrackStream;
//# sourceMappingURL=mediatrack-stream.js.map