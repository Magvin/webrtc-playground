"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRTCPeerConnection = void 0;
const events_1 = require("events");
const NodeDataChannel = require("node-datachannel");
const datachannel_stream_1 = require("./datachannel-stream");
class MockRTCPeerConnection extends events_1.EventEmitter {
    constructor() {
        super();
        this.rawConn = new NodeDataChannel.PeerConnection("MockRTCPeer", { iceServers: [] });
        this.channels = [];
        this.rawConn.onDataChannel((channel) => {
            const channelStream = new datachannel_stream_1.DataChannelStream(channel);
            this.channels.push(channelStream);
            channel.onClosed(() => {
                const channelIndex = this.channels.findIndex(c => c === channelStream);
                if (channelIndex !== -1) {
                    this.channels.splice(channelIndex, 1);
                }
            });
            channelStream.on('error', (error) => {
                console.error('Channel error:', error);
            });
            this.emit('channel-open', channelStream);
        });
    }
    setRemoteDescription(description) {
        const { type: offerType, sdp: offerSdp } = description;
        if (!offerSdp)
            throw new Error("Cannot set MockRTC peer description without providing an SDP");
        this.rawConn.setRemoteDescription(offerSdp, offerType[0].toUpperCase() + offerType.slice(1));
    }
    /**
     * Gets the local description for this connection, waiting until gathering is complete to provide a
     * full result. Because this waits for gathering, it will not resolve if no DataChannel, other
     * tracks or remote description have been provided beforehand.
     */
    getLocalDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Detect offer vs answer case here.
            const setupChannel = this.rawConn.createDataChannel('mockttp.setup.channel');
            yield new Promise((resolve) => {
                this.rawConn.onGatheringStateChange((state) => {
                    if (state === 'complete')
                        resolve();
                });
                // Handle race conditions where gathering has already completed
                if (this.rawConn.gatheringState() === 'complete')
                    resolve();
            });
            const sessionDescription = this.rawConn.localDescription();
            setupChannel.close(); // TODO: Does this work? Goal is to get a channel without actually sending open msg.
            return sessionDescription;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            const closedPromise = new Promise((resolve) => {
                if (this.rawConn.state() === 'closed')
                    resolve();
                this.rawConn.onStateChange((state) => {
                    if (state === 'closed')
                        resolve();
                });
            });
            this.rawConn.close();
            yield closedPromise;
        });
    }
}
exports.MockRTCPeerConnection = MockRTCPeerConnection;
//# sourceMappingURL=peer-connection.js.map