"use strict";
/*
 * SPDX-FileCopyrightText: 2022 Tim Perry <tim@httptoolkit.tech>
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RTCConnection = void 0;
const _ = require("lodash");
const crypto_1 = require("crypto");
const events_1 = require("events");
const SDP = require("sdp-transform");
const NodeDataChannel = require("node-datachannel");
const datachannel_stream_1 = require("./datachannel-stream");
const mediatrack_stream_1 = require("./mediatrack-stream");
/**
 * An RTC connection is a single connection. This base class defines the raw connection management and
 * tracking logic for a generic connection. The MockRTCConnection subclass extends this and adds
 * logic to support control channels, proxying and other MockRTC-specific additions.
 */
class RTCConnection extends events_1.EventEmitter {
    constructor() {
        super();
        this.id = (0, crypto_1.randomUUID)();
        // Set to null when the connection is closed, as otherwise calling any method (including checking
        // the connection state) will segfault the process.
        this.rawConn = new NodeDataChannel.PeerConnection("MockRTCConnection", { iceServers: [], forceMediaTransport: true });
        this._connectionMetadata = {};
        this.trackedChannels = [];
        this.trackedMediaTracks = [];
        this.sessionApi = {
            sessionId: this.id,
            createOffer: (options = {}) => __awaiter(this, void 0, void 0, function* () {
                if (options.connectionMetadata) {
                    this._connectionMetadata = Object.assign(Object.assign({}, this._connectionMetadata), options.connectionMetadata);
                }
                if (options.mirrorSDP) {
                    return this.getMirroredLocalOffer(options.mirrorSDP, {
                        addDataStream: !!options.addDataStream
                    });
                }
                else {
                    return this.buildLocalDescription();
                }
            }),
            completeOffer: (answer) => __awaiter(this, void 0, void 0, function* () {
                this.setRemoteDescription(answer);
            }),
            answerOffer: (offer, options = {}) => __awaiter(this, void 0, void 0, function* () {
                if (options.connectionMetadata) {
                    this._connectionMetadata = Object.assign(Object.assign({}, this._connectionMetadata), options.connectionMetadata);
                }
                this.setRemoteDescription(offer);
                if (options.mirrorSDP) {
                    return this.getMirroredLocalAnswer(options.mirrorSDP);
                }
                else {
                    return this.buildLocalDescription();
                }
            })
        };
        this.rawConn.onDataChannel((channel) => {
            if (!this.rawConn)
                return; // https://github.com/murat-dogan/node-datachannel/issues/103
            this.trackNewChannel(channel, { isLocal: false });
        });
        this.rawConn.onTrack((track) => {
            if (!this.rawConn)
                return; // https://github.com/murat-dogan/node-datachannel/issues/103
            this.trackNewMediaTrack(track, { isLocal: false });
        });
        // Important to remember that only node-dc only allows one listener per event. To handle that,
        // we reemit important events here to use normal node event methods instead:
        this.rawConn.onStateChange((state) => {
            this.emit('connection-state-changed', state);
        });
        this.on('connection-state-changed', (state) => {
            if (state === 'connected') {
                this.emit('connection-connected');
            }
            else if (state === 'closed' || state === 'disconnected') {
                this.emit('connection-closed');
                this.remoteDescription = undefined;
                this.localDescription = undefined;
            }
        });
    }
    get metadata() {
        return this._connectionMetadata;
    }
    get channels() {
        return this.trackedChannels
            .map(channel => channel.stream);
    }
    get localChannels() {
        return this.trackedChannels
            .filter(channel => channel.isLocal)
            .map(channel => channel.stream);
    }
    get remoteChannels() {
        return this.trackedChannels
            .filter(channel => !channel.isLocal)
            .map(channel => channel.stream);
    }
    get mediaTracks() {
        return this.trackedMediaTracks
            .map(track => track.stream);
    }
    get localMediaTracks() {
        return this.trackedMediaTracks
            .filter(track => track.isLocal)
            .map(track => track.stream);
    }
    get remoteMediaTracks() {
        return this.trackedMediaTracks
            .filter(track => !track.isLocal)
            .map(track => track.stream);
    }
    createDataChannel(label) {
        if (!this.rawConn)
            throw new Error("Can't create data channel after connection is closed");
        const channel = this.rawConn.createDataChannel(label);
        return this.trackNewChannel(channel, { isLocal: true });
    }
    trackNewChannel(channel, options) {
        const channelStream = new datachannel_stream_1.DataChannelStream(channel);
        this.trackedChannels.push({ stream: channelStream, isLocal: options.isLocal });
        channelStream.on('close', () => {
            const channelIndex = this.trackedChannels.findIndex(c => c.stream === channelStream);
            if (channelIndex !== -1) {
                this.trackedChannels.splice(channelIndex, 1);
            }
        });
        channelStream.on('error', (error) => {
            console.error('Channel error:', error);
        });
        this.emit('channel-created', channelStream);
        this.emit(`${options.isLocal ? 'local' : 'remote'}-channel-created`, channelStream);
        channelStream.once('channel-open', () => {
            this.emit('channel-open', channelStream);
            this.emit(`${options.isLocal ? 'local' : 'remote'}-channel-open`, channelStream);
        });
        return channelStream;
    }
    trackNewMediaTrack(track, options) {
        const trackStream = new mediatrack_stream_1.MediaTrackStream(track);
        this.trackedMediaTracks.push({ stream: trackStream, isLocal: options.isLocal });
        trackStream.on('close', () => {
            const trackIndex = this.trackedMediaTracks.findIndex(c => c.stream === trackStream);
            if (trackIndex !== -1) {
                this.trackedMediaTracks.splice(trackIndex, 1);
            }
        });
        trackStream.on('error', (error) => {
            console.error('Media track error:', error);
        });
        this.emit('track-created', trackStream);
        this.emit(`${options.isLocal ? 'local' : 'remote'}-track-created`, trackStream);
        trackStream.once('track-open', () => {
            this.emit('track-open', trackStream);
            this.emit(`${options.isLocal ? 'local' : 'remote'}-track-open`, trackStream);
        });
        return trackStream;
    }
    setRemoteDescription(description) {
        var _a;
        if (!this.rawConn)
            throw new Error("Can't set remote description after connection is closed");
        this.remoteDescription = Object.assign(Object.assign({}, description), { parsedSdp: SDP.parse((_a = description.sdp) !== null && _a !== void 0 ? _a : '') });
        const { type: offerType, sdp: offerSdp } = description;
        if (!offerSdp)
            throw new Error("Cannot set MockRTC peer description without providing an SDP");
        this.rawConn.setRemoteDescription(offerSdp, offerType[0].toUpperCase() + offerType.slice(1));
    }
    /**
     * Gets the local description for this connection, waiting until gathering is complete to provide a
     * full result. Because this waits for gathering, it will not resolve if no DataChannel, other
     * tracks or remote description have been provided beforehand.
     */
    buildLocalDescription() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rawConn)
                throw new Error("Can't get local description after connection is closed");
            let setupChannel;
            if (this.rawConn.gatheringState() === 'new') {
                // We can't create an offer until we have something to negotiate, but we don't want to
                // negotiate ourselves when we don't really know what's being negotiated here. To work
                // around that, we create a channel to trigger gathering & get an offer, and then we
                // remove it before the offer is delivered, so it's never visible remotely.
                setupChannel = this.rawConn.createDataChannel('mockrtc.setup-channel');
            }
            yield new Promise((resolve) => {
                this.rawConn.onGatheringStateChange((state) => {
                    if (state === 'complete')
                        resolve();
                });
                // Handle race conditions where gathering has already completed
                if (this.rawConn.gatheringState() === 'complete')
                    resolve();
            });
            if (!this.rawConn)
                throw new Error("Connection was closed while building local description");
            const sessionDescription = this.rawConn.localDescription();
            setupChannel === null || setupChannel === void 0 ? void 0 : setupChannel.close(); // Close the temporary setup channel, if we created one
            this.localDescription = Object.assign(Object.assign({}, sessionDescription), { parsedSdp: SDP.parse((_a = sessionDescription.sdp) !== null && _a !== void 0 ? _a : '') });
            return sessionDescription;
        });
    }
    getRemoteDescription() {
        if (!this.rawConn)
            throw new Error("Can't get remote description after connection is closed");
        return this.remoteDescription;
    }
    getLocalDescription() {
        if (!this.rawConn)
            throw new Error("Can't get local description after connection is closed");
        return this.localDescription;
    }
    getSelectedCandidates() {
        if (!this.rawConn)
            throw new Error("Can't get selected candidates after connection is closed");
        const candidates = this.rawConn.getSelectedCandidatePair();
        if (!candidates)
            return undefined;
        // Rename transportType -> protocol, to better match the browser WebRTC APIs
        return {
            local: Object.assign(Object.assign({}, _.omit(candidates.local, 'transportType')), { type: candidates.local.type, protocol: candidates.local.transportType.toLowerCase() }),
            remote: Object.assign(Object.assign({}, _.omit(candidates.remote, 'transportType')), { type: candidates.remote.type, protocol: candidates.remote.transportType.toLowerCase() })
        };
    }
    getMirroredLocalOffer(sdpToMirror, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rawConn)
                throw new Error("Can't get local description after connection is closed");
            const offerToMirror = SDP.parse(sdpToMirror);
            const mediaStreamsToMirror = offerToMirror.media.filter(media => media.type !== 'application');
            const shouldMirrorDataStream = offerToMirror.media.some(media => media.type === 'application');
            mediaStreamsToMirror.forEach((mediaToMirror) => {
                var _a, _b;
                // Skip media tracks that we already have
                if (this.mediaTracks.find(({ mid }) => mid === mediaToMirror.mid))
                    return;
                const mid = mediaToMirror.mid.toString();
                const direction = sdpDirectionToNDCDirection(mediaToMirror.direction);
                const media = mediaToMirror.type === 'video'
                    ? new NodeDataChannel.Video(mid, direction)
                    : new NodeDataChannel.Audio(mid, direction);
                // Copy SSRC data (awkward translation between per-attr and full-value structures)
                const ssrcs = (_b = (_a = mediaToMirror.ssrcs) === null || _a === void 0 ? void 0 : _a.reduce((ssrcs, kv) => {
                    var _a;
                    ssrcs[_a = kv.id] || (ssrcs[_a] = {});
                    ssrcs[kv.id][kv.attribute] = kv.value;
                    return ssrcs;
                }, {})) !== null && _b !== void 0 ? _b : {};
                Object.keys(ssrcs).forEach((id) => {
                    var _a, _b;
                    const ssrcAttrs = ssrcs[id];
                    const [msid, trackId] = (_b = (_a = ssrcAttrs.msid) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
                    if (!msid) {
                        media.addSSRC(parseInt(id, 10), ssrcAttrs['cname']);
                    }
                    else {
                        media.addSSRC(parseInt(id, 10), ssrcAttrs['cname'], msid, trackId);
                    }
                });
                const track = this.rawConn.addTrack(media);
                this.trackNewMediaTrack(track, { isLocal: true });
            });
            let setupChannel;
            const channelRequiredForDescription = this.rawConn.gatheringState() === 'new' &&
                !mediaStreamsToMirror.length;
            if (shouldMirrorDataStream || channelRequiredForDescription || options.addDataStream) {
                // See getLocalDescription() above: if we want a description and we have no media, we
                // need to make a stub channel to allow us to negotiate _something_.
                // In addition, we might actually have data channels to mirror. In that case, we need
                // to create a temporary data channel to force that negotiation (which will be closed
                // again shortly, so that it never actually gets created).
                setupChannel = this.rawConn.createDataChannel('mockrtc.setup-channel');
            }
            this.rawConn.setLocalDescription(NodeDataChannel.DescriptionType.Offer);
            yield new Promise((resolve) => {
                this.rawConn.onGatheringStateChange((state) => {
                    if (state === 'complete')
                        resolve();
                });
                // Handle race conditions where gathering has already completed
                if (this.rawConn.gatheringState() === 'complete')
                    resolve();
            });
            if (!this.rawConn)
                throw new Error("Connection was closed while building the local description");
            const localDesc = this.rawConn.localDescription();
            setupChannel === null || setupChannel === void 0 ? void 0 : setupChannel.close(); // Close the temporary setup channel, if we created one
            const offerSDP = SDP.parse(localDesc.sdp);
            mirrorMediaParams(offerToMirror, offerSDP);
            localDesc.sdp = SDP.write(offerSDP);
            this.localDescription = Object.assign(Object.assign({}, localDesc), { parsedSdp: offerSDP });
            return this.localDescription;
        });
    }
    getMirroredLocalAnswer(sdpToMirror) {
        return __awaiter(this, void 0, void 0, function* () {
            const localDesc = this.rawConn.localDescription();
            const answerToMirror = SDP.parse(sdpToMirror);
            const answerSDP = SDP.parse(localDesc.sdp);
            mirrorMediaParams(answerToMirror, answerSDP);
            localDesc.sdp = SDP.write(answerSDP);
            this.localDescription = Object.assign(Object.assign({}, localDesc), { parsedSdp: answerSDP });
            return this.localDescription;
        });
    }
    waitUntilConnected() {
        return new Promise((resolve, reject) => {
            if (!this.rawConn)
                throw new Error("Connection closed while/before waiting until connected");
            this.on('connection-state-changed', (state) => {
                if (state === 'connected')
                    resolve();
                if (state === 'failed') {
                    reject(new Error("Connection failed while waiting for connection"));
                }
            });
            if (this.rawConn.state() === 'connected')
                resolve();
            if (this.rawConn.state() === 'failed') {
                reject(new Error("Connection failed while waiting for connection"));
            }
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rawConn)
                return; // Already closed
            const { rawConn } = this;
            this.rawConn = null; // Drop the reference, so nothing tries to use it after close
            this.remoteDescription = undefined;
            this.localDescription = undefined;
            if (rawConn.state() === 'closed')
                return;
            rawConn.close();
            this.emit('connection-closed');
        });
    }
}
exports.RTCConnection = RTCConnection;
function sdpDirectionToNDCDirection(direction) {
    if (direction === 'inactive')
        return "Inactive" /* Inactive */;
    else if ((direction === null || direction === void 0 ? void 0 : direction.length) === 8) {
        return direction[0].toUpperCase() +
            direction.slice(1, 4) +
            direction[4].toUpperCase() +
            direction.slice(5);
    }
    else {
        return "Unknown" /* Unknown */;
    }
}
;
/**
 * Takes two parsed descriptions (typically a real description we want to mock, and our own current
 * self-generated description) and modifies the target description sure that the media params for
 * each stream in the source description match.
 *
 * In theory, this should guarantee that RTP packets generated by the source and forwarded through
 * the target's connection can be interpreted by somebody connected to the target.
 */
function mirrorMediaParams(source, target) {
    target.msidSemantic = source.msidSemantic;
    const sourceMediaStreams = source.media.filter(m => m.type !== 'application');
    sourceMediaStreams.forEach((sourceMedia) => {
        const targetMedia = target.media
            .find((targetMedia) => targetMedia.mid === sourceMedia.mid);
        if (!targetMedia) {
            throw new Error(`Missing mid ${sourceMedia.mid} in target when mirroring media params`);
        }
        if (sourceMedia.type !== targetMedia.type) {
            throw new Error(`Unexpected media type (${targetMedia.type}) for mid ${targetMedia.mid} when mirroring media params`);
        }
        // Copy all the semantic parameters of the RTP & RTCP streams themselves, so that RTP packets
        // can be forwarded correctly, but without copying the fingerprint or similar, so we can still
        // act as a MitM to intercept the packets:
        targetMedia.msid = sourceMedia.msid;
        targetMedia.protocol = sourceMedia.protocol;
        targetMedia.ext = sourceMedia.ext;
        targetMedia.payloads = sourceMedia.payloads;
        targetMedia.rtp = sourceMedia.rtp;
        targetMedia.fmtp = sourceMedia.fmtp;
        targetMedia.rtcp = sourceMedia.rtcp;
        targetMedia.rtcpFb = sourceMedia.rtcpFb;
        targetMedia.ssrcGroups = sourceMedia.ssrcGroups;
        // SSRC info is especially important here: this is used to map RTP SSRCs to track mids, so if
        // this is incorrect, the recipient track will not receive the data we're sending.
        // Although in some cases we do already have some SSRC info here, for offers where we've already
        // defined the tracks ourselves, libdatachannel doesn't support all params and it's best to copy
        // the full definition itself directly to make sure they match:
        targetMedia.ssrcs = sourceMedia.ssrcs;
    });
}
//# sourceMappingURL=rtc-connection.js.map